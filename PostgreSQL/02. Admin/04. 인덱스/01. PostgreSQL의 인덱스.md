# PostgreSQL의 인덱스

## 인덱스란
책의 색인(Index)와 같은 역할을 하는 핵심 오브젝트로, 어떤 단어가 몇 페이지에 있는지 찾을 때 색인을 통해 쉽게 찾을 수 있다. 색인은 다음과 같은 특징이 있다.
- 단어가 가나다 순서로 되어 있다.
- 단어와 페이지로 짝지어져 있다.

단어들이 가나다 순서로 되어 있으므로 내가 찾는 단어의 유무를 쉽게 찾을 수 있으며, 단어 옆에 페이지를 보고 곧바로 해당 페이지를 찾아가면 된다. 인덱스도 마찬가지로 **데이터, 포인터 정보**로 이루어져 있고 데이터 또한 정렬된 상태를 유지한다. 따라서 데이터를 쉽게 찾아 해당 테이블을 빠르게 가져옴으로써 빠르게 조회할 수 있다.

## 인덱스의 용도
- SQL 실행 중 테이블에 접근하는 방법은 Sequential Scan(Full Table Scan)과 Index Scan이 있음.
- Sequential Scan을 많이 실행하면 다음과 같은 부작용이 있음.
  1. 디스크I/O를 과하게 유발.
  2. CPU사용률 증가
  3. SQL 응답시간이 현저히 저하.
- 데이터 조회 성능을 극적으로 향상시키기 위해 인덱스가 필요함.
## 인덱스의 단점
- 테이블 데이터를 추가/변경/삭제할 때, **인덱스 데이터도 함께 추가/변경/삭제해야 함**. 조회성능이 향상되는 만큼 변경시 성능은 저하됨. 인덱스 수가 많을 수록 DML성능이 저하됨.
- 불필요한 인덱스가 많을 경우 **디스크 공간을 낭비**하게 됨. 인덱스 또한 물리적인 데이터파일이 있고, 이 또한 디스크의 용량을 차지하므로 불필요한 인덱스는 지워야 함.

## PostgreSQL의 인덱스 유형
### B-Tree
- 거의 대부분의 요구사항에 맞는 보편적인 인덱스.
- 뿌리에 해당하는 Root Node에 가지같이 뻗어있는 Branch Node, 가지 끝에 달린 Leaf Node로 구성된다. 또한 Leaf Node는 이웃한 Leaf Node와 연결되어 있어 이웃한 Leaf Node로 스캔이 가능하다.
- Root Node에서 Leaf Node까지 거치는 Node 수를 Level이라고 하는데, B-Tree 인덱스는 모든 Leaf Node의 Level을 동일하게 유지하도록 되어 있다.
- Leaf Node에는 컬럼 데이터와 포인터 정보가 있다. 컬럼 데이터는 순서대로 정렬된 상태를 유지하며, 데이터를 찾으면 포인터 정보를 가지고 Shared Buffer에 페이지를 요청한다.
### Hash
- 특정 블록에 트래픽이 몰리는 Hot Block현상을 방지하기 위한 인덱스
- 크기 비교연산 (>, <, >=, <=)은 불가능. 오직 (=, <>)연산자만 지원
### GiST
- 지리, 기하 데이터 인덱싱에 활용
### GIN
- 배열이나 텍스트 전문 검색에 활용.
### BRIN
- 용량이 매우 크고, 성별이나 XX여부와 같이 값의 중복이 많은 데이터를 매우 높은 효율로 압축할 수 있는 인덱스.
### Partial Index
- where조건을 걸어, 테이블의 특정 데이터만으로 인덱스를 생성.

## 인덱스 생성
### 인덱스 생성 기본구문
```
CREATE INDEX INDEX_NAME ON TABLE_NAME(COLUMN1, COLUMN2) TABLESPACE TABLESPACE_NAME;
```
- B-Tree 인덱스를 생성하는 가장 기본적인 구문.
- TABLESPACE_NAME 테이블스페이스에 생성 지정.

### Partial Index 생성
```
CREATE INDEX INDEX_NAME ON TABLE_NAME(COLUMN1) WHERE COLUMN1 < 100;
```
- `COLUMN1 < 100` 조건을 만족하는 TABLE_NAME 테이블의 값만 인덱싱


