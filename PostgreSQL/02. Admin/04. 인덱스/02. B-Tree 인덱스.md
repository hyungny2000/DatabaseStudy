# B-Tree 인덱스

## 정의
- B-Tree 구조의 인덱스.
- PostgreSQL을 포함한 거의 모든 DBMS에서 보편적으로 권고하는 인덱스.

## 구분
### Unique 인덱스/Non-Unique 인덱스
- Unique 인덱스 : Primary Key제약 또는 Unique 제약이 있는 경우 생성되는 인덱스로, 모든 값이 테이블 내에서 유일함을 보장하는 인덱스.
- Non-Unique 인덱스 : PK/UK 이외의 컬럼으로 생성하는 인덱스로, 모든 값이 테이블 내에서 유일함을 보장하지 않는 인덱스. 설령 모든 값이 테이블 내에서 유일하다고 해도 PK/UK제약이 없으므로 Non-unique한 것으로 간주한다.

### 단일 인덱스/복합 인덱스
- 단일 인덱스 : 테이블 컬럼 1개로 생성한 인덱스를 말한다.
- 복합 인덱스 : 테이블 컬럼 2개 이상으로 생성한 인덱스를 말한다.

## B-Tree 구조
### 구조 및 용어
B-Tree는 흡사 나무와 비슷한 구조를 하고 있다. 
1. Root Node : 인덱스 최상단, 즉 뿌리에 해당하는 노드. 여기서 노드는 서버가 아니라 데이터 블록을 의미한다.
2. Branch Node : 인덱스 중간, 가지에 해당하는 노드. 검색대상 데이터와 Leaf Node를 연결해 준다. 인덱스 크기가 작으면 Branch Node가 생략되는 경우가 있다.
3. Leaf Node : 인덱스 최말단, 잎에 해당하는 노드. 검색대상 데이터와 Row를 바로 찾아갈 수 있는 Pointer 정보가 있다. Leaf Node는 이웃한 Leaf Node와 연결되어 있어 스캔이 가능하며, 데이터를 기준으로 항상 정렬된 상태를 유지하도록 되어 있다.
4. Level : Root Node부터 Leaf Node에 이르기까지 거쳐야 하는 단계 수를 칭한다. B-Tree 구조는 모든 Leaf Node에서 이 Level이 일정하도록 관리한다.
5. Random Access : 인덱스 Leaf Node에서 해당되는 테이블 페이지를 Fetch하는 과정을 Random Access라고 한다.
```
                                          ____ [Leaf Node]
                                         |         |
               _______ [Branch Node#1] __|____ [Leaf Node]
               |                         |         |                                       
[Root Node]----|                         |____ [Leaf Node] -----(Ramdom Access)------> [Table Page]
               |                                   |
               |                          ____ [Leaf Node]
               _______ [Branch Node#2]___|         |
                                         |____ [Leaf Node]

     |__________________(Level = 2)________________|
```
[B-Tree 인덱스 전체 구조]
```

           [Leaf Node#1]                            [Leaf Node#2]                                 [Leaf Node#3]
| col1  |          Pointer        |       |  col1  |        Pointer           |       |  col1  |        Pointer           |
|  가   |  BufferTag#1 (offset=0) |       |   나   |  BufferTag#1 (offset=6)  |       |   라   |  BufferTag#2 (offset=1)  |
|  가   |  BufferTag#1 (offset=1) |       |   나   |  BufferTag#1 (offset=7)  |       |   라   |  BufferTag#2 (offset=2)  |
|  가   |  BufferTag#1 (offset=2) | <---> |   나   |  BufferTag#3 (offset=0)  | <---> |   라   |  BufferTag#2 (offset=3)  |
|  가   |  BufferTag#2 (offset=0) |       |   다   |  BufferTag#1 (offset=8)  |       |   마   |  BufferTag#2 (offset=4)  |
|  가   |  BufferTag#1 (offset=4) |       |   다   |  BufferTag#1 (offset=9)  |       |   바   |  BufferTag#2 (offset=5)  |
|  나   |  BufferTag#1 (offset=5) |       |   라   |  BufferTag#1 (offset=10) |       |   사   |  BufferTag#2 (offset=6)  |

```
[B-Tree 인덱스 Leaf Node 구조]

## 인덱스 스캔 방식
### Index Unique Scan
- 인덱스 스캔 방식 중에서 가장 빠른 방식
- 오직 Primary Key (또는 Unique Index) 인덱스의 컬럼을 전부 동등조건(=)으로 조건을 부여할 때 사용가능하다.
- Root Node, Branch Node, Leaf Node 하나씩 Fetch, 마지막으로 Random Access를 통해 Table Page를 Fetch하는 방식이다.
- Unique Scan 1회 시 블록I/O는 총 4번 발생한다.
```
                                          ____ [Leaf Node]
                              2.         |         | 
               _______ [Branch Node#1] __|____ [Leaf Node]
     1.        |                         |     3.  |                   4.                    
[Root Node]----|                         |____ [Leaf Node] -----(Ramdom Access)------> [Table Page]
               |                                   |
               |                          ____ [Leaf Node]
               _______ [Branch Node#2]___|         |
                                         |____ [Leaf Node]
```

### Index Range Scan
- 가장 보편적인 스캔 방식
- non-unique 인덱스이거나, 범위 조건 (Between, <, > 등) 또는 nonunique 값을 동등조건(=)으로 실행할 때도 Range Scan으로 동작한다.
- Root Node, Branch Node, Leaf Node 까지 방문한다.
- 처음 스캔한 Leaf Node부터 Random Access 실행한 후, 다음 Leaf Node를 스캔한다. 조건을 만족하는 한 다음 Leaf Node를 거듭 스캔한다.
- 아래 예시에서 블록I/O는 8번 발생했다.
```
                                          ____ [Leaf Node]
                              2.         |         | 
               _______ [Branch Node#1] __|____ [Leaf Node]
     1.        |                         |     3.  |                  4.                     
[Root Node]----|                         |____ [Leaf Node] -----(Ramdom Access)------> [Table Page]
               |                               5.   |                 6.
               |                          ____ [Leaf Node] -----(Ramdom Access)------> [Table Page]
               _______ [Branch Node#2]___|     7.  |                  8.
                                         |____ [Leaf Node] -----(Ramdom Access)------> [Table Page]
```

### Index Only Scan
- 인덱스 컬럼만 스캔하도록 SQL이 구성될 경우 사용 가능한 방식
- 테이블 페이지를 Fetch할 필요 없이 인덱스 Leaf Node의 데이터를 바로 백엔드 프로세스로 반환한다.
- Random Access가 없으므로 속도가 빠른 편이다.
- PostgreSQL 한정으로, Index Only Scan임에도 테이블 페이지를 Fetch해야 하는 경우가 있다.
- 아래 예시에서 블록I/O는 총 5번 발생했다. (1,2,3,5,7)
```
                                          ____ [Leaf Node]
                              2.         |         | 
               _______ [Branch Node#1] __|____ [Leaf Node]
     1.        |                         |     3.  |                  4.                     
[Root Node]----|                         |____ [Leaf Node] --------------------------> [Backend Process]
               |                               5.   |                 6.                  |   |
               |                          ____ [Leaf Node] -----(Ramdom Access)-----------    |
               _______ [Branch Node#2]___|     7.  |                  8.                      |
                                         |____ [Leaf Node] -----(Ramdom Access)----------------
```
### Index Full Scan
- 인덱스의 모든 Leaf Node를 스캔하는 방식
- 의도하지 않았다면, 인덱스를 잘못 설계했을 때 이상증상으로 나타나는 경우가 많음. 주의해야 함.
- 아래 예시에서 블록I/O는 12번 발생했다.
```
                                               3.                     4.
                                          ____ [Leaf Node] -----(Ramdom Access)------> [Table Page]
                              2.         |     5.  |                  6.
               _______ [Branch Node#1] __|____ [Leaf Node] -----(Ramdom Access)------> [Table Page]
     1.        |                         |     7.  |                  8.                     
[Root Node]----|                         |____ [Leaf Node] -----(Ramdom Access)------> [Table Page]
               |                               9.   |                10.
               |                          ____ [Leaf Node] -----(Ramdom Access)------> [Table Page]
               _______ [Branch Node#2]___|     11.  |                12.
                                         |____ [Leaf Node] -----(Ramdom Access)------> [Table Page]
```
> ### 참고) Index Skip Scan 미지원
> Index Skip Scan은 인덱스 선두컬럼이 where조건에 없을 때 선두컬럼을 skip하고 인덱스 두번째 컬럼을 스캔하는 방식이다.
> PostgreSQL에서는 Index Skip Scan을 지원하지 않는다.

## 인덱스 스캔 입출력 특징
### Single Block 입출력
- 한 번에 하나의 Block을 Fetch할 수 있다.
- Sequential Scan (Full Table Scan)은 Multi Block Scan으로 동작하므로, 다소 불리하다.
### SQL의 정렬을 대신할 수 있다.
- 인덱스 컬럼은 항상 정렬된 상태를 유지하도록 설계되었다.
- 만일 인덱스 컬럼으로 order by를 할 경우, 인덱스 스캔으로 정렬(Sorting)을 생략할 수 있다. SQL의 주요 튜닝포인트이다.
