# 인덱스 유지보수
## Lock 없는 인덱스 생성작업
일반적으로 인덱스 생성시 테이블에 Table Lock을 걸게 되어 DML을 방해하므로, 서비스 중에는 가급적 인덱스 생성을 하지 말아야 한다. 하지만 DML을 막지 않고 인덱스를 생성하는 **CONCURRENTLY**옵션을 사용할 수 있다. CONCURRENTLY 옵션을 사용하면, 인덱스 생성 중에도 DML을 막지 않으며, DML트랜잭션이 끝날 때까지 인덱스 생성을 중지한다. **서비스 운영은 가능하지만 인덱스 생성은 그만큼 더디게 진행되므로 역시 서비스가 한가한 시간대에 해야 한다.**
```
CREATE INDEX CONCURRENTLY INDEX_NAME ON TABLE_NAME(COLUMN1, COLUMN2)
TABLESPACE TABLESPACE_NAME;
```

## Reindex 작업
DML이 누적되면서 B-Tree인덱스의 Leaf Node에 있는 데이터도 생성과 삭제를 거듭하게 된다. 인덱스 데이터는 항상 정렬된 상태를 유지해야 하므로, 중간중간 빈 공간이 있어도 곧바로 활용하기 어렵다는 특징이 있다. 또한 아예 텅 빈 Leaf Node는 회수 후 재사용이 가능하지만, 데이터가 하나라도 있는 Leaf Node는 회수가 안된다. 이런 현상을 PostgreSQL에서는 Index Bloating(다른 DBMS에서는 Skewed Index, Sparsed Index)라고 부른다.       

이를 위해 PostgreSQL은 주기적으로 인덱스를 Reindex하는 기능을 제공한다.
```
REINDEX INDEX INDEX_NAME;
```
인덱스를 재생성하는 작업이므로, DML트랜잭션을 막게 된다. 꼭 CONCURRENTLY옵션을 사용하도록 하자.

## Cluster 작업
