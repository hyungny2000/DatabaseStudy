## Autovacuum
autovacuum daemon 프로세스에 의해 자동으로 vacuum 수행으로 Anti XID Wraparound를 방지한다.

#### Autovacuum Age 관련 파라미터
- vacuum_vacuum_table_age
  - autovacuum 시 freeze할 대상 테이블의 Age

#### Autovacuum 임계치 관련 글로벌 파라미터
autovacuum daemon을 임의로 동작시키는 방법은 없으며, 다음 파라미터로부터 임계치를 계산하여, 특정 임계치를 만족할 때 autovacuum이 동작한다.
| 파라미터 | 설명 | 기본값 |
| ---  | --- | --- |
 | autovacuum | autovacuum 활성화 여부 | on |
 | autovacuum_freeze_max_age | autovacuum을 강제 실행할 테이블 Age의 임계치 | 2억 | 
 | autovacuum_vacuum_threshold | autovacuum 활성을 위한 최소한의 update row 수 | 50 |
 | autovacuum_vacuum_insert_threshold | autovacuum 활성을 위한 최소한의 삽입된 튜플의 수 | 1000 |
 | autovacuum_analyze_threshold | autovacuum analyze 활성을 위한 최소한의 update row 수 | 50 |
 | autovacuum_vacuum_scale_factor | autovacuum 활성을 위해 변경되어야 할 테이블 전체 row수 대비 Update 비율 | 0.2 |
 | autovacuum_analyze_scale_factor | autovacuum analyze 활성을 위해 변경되어야 할 테이블 전체 row수 대비 Update 비율 | 0.1 |
- autovacuum=off로 설정했어도 Anti XID Wraparound를 위해 DB에서 임의로 autovacuum을 동작시킬 수 있다.

#### autovacuum 임계치 관련 테이블 별 파라미터 ([테이블 파라미터 매뉴얼](https://www.postgresql.org/docs/current/sql-createtable.html#SQL-CREATETABLE-STORAGE-PARAMETERS))
postgresql.conf 설정파일의 파라미터는 DB전역적인 값이다. 이와 다르게, 테이블 별로 파라미터를 설정 가능하다. 파라미터명과 기능은 글로벌 파라미터와 동일하며, 설정할 경우 글로벌 파라미터에 우선한다.


#### 기타 설정값
 | 파라미터 | 설명 | 기본값 |
 | ---  | --- | --- |
 | autovacuum_max_workers | 최대 autovacuum daemon 개수  | 3 |    
 | autovacuum_naptime | autovacuum 사이의 최소 지연시간 | 1분 |
 | autovacuum_vacuum_cost_limit | autovacuum이 비용을 얼마나 사용할지 결정 | 200 | 
 | autovacuum_vacuum_cost_delay | autovacuum_vacuum_cost_limit를 초과할 때 대기시간 (ms) | 2 |

#### Autovacuum 데몬 동작 임계치
1. Vacuum 임계치
   Update/Delete된 Row건수 (Update/Delete로 인해 dead된 tuples 수)를 기준으로 하는 autovacuum 임계치는 다음과 같다.
   ```
   vacuum threshold = autovacuum_vacuum_threshold + autovacuum_vacuum_scale_factor * pg_class.reltuples of the table;
   ```   
   - autovacuum_vacuum_threshold : autovacuum_vacuum_threshold 파라미터 값
   - autovacuum_vacuum_scale_factor : autovacuum_vacuum_scale_factor 파라미터 값
   - pg_class.reltuples : 테이블의 튜플 수
  
3. Vacuum insert 임계치
   Insert된 row건수를 기준으로 하는 autovacuum 임계치는 다음과 같다.
   ```
   vacuum insert threshold = autovacuum_vacuum_insert_threshold + autovacuum_vacuum_scale_factor * pg_class.reltuples of the table
   ``` 
   - autovacuum_vacuum_insert_threshold : autovacuum_vacuum_insert_threshold 파라미터 값

4. Vacuum analyze 임계치
    테이블 analyze를 위한 autovacuum analyze 임계치는 다음과 같다.
   ```
   vacuum analyze threshold = autovacuum_analyze_threshold + autovacuum_analyze_scale_factor * pg_class.reltuples of the table
   ```

5. autovacuum_freeze_max_age 파라미터
   위의 thread + scale_factor * reltuples 계산값보다 autovacuum_freeze_max_age 파라미터 값이 우선한다.

#### Autovacuum 테스트
1. autovacuum_vacuum_threshold, autovacuum_vacuum_scale_factor 값, vacuum_freeze_table_age 값 설정 후 리로드
   ```
   vi postgresql.conf

   vacuum_freeze_table_age = 50

   autovacuum_vacuum_threshold = 50
   autovacuum_vacuum_scale_factor = 0.2

   :wq

   pg_ctl reload
   ```

2. 테스트 테이블 준비
   ```
   create table test1 select generate_series(1,1000);

   nano=# select relname, reltuples, age(relfrozenxid) from pg_class where relname='test1';
     relname | reltuples | age
    ---------+-----------+-----
     test1   |      1000 |   3
    (1 row)
   ```
   - autovacuum 임계치 계산
     - autovacuum_vacuum_threshold + autovacuum_vacuum_scale_factor * pg_class.reltuples of the table;
     - 50 + 0.2 * 1000 = 250
     - autovacuum 임계치가 250건
  3. 테이블 260건 Update
   ```
   update test1 set col1 = col1 + 1000 where col1 <= 260; 
   ```
   - 대략 260건만 Update하면 autovacuum 조건이 되지 않을까 함.
  
  4. 테이블 Age, vacuum Freeze 여부 확인
   ```
   select relname, reltuples, age(relfrozenxid) from pg_class where relname='test1';
    relname | reltuples | age
   ---------+-----------+-----
    test1   |      1000 |   5

    SELECT lp, t_xmin, t_xmax, t_ctid, t_infomask::bit(16)
           ,b'0000001100000000' & t_infomask::bit(16) = b'0000001100000000' as XMIN_FROZEN
           ,t_data
   FROM heap_page_items(get_raw_page('test1', 0));
     lp  | t_xmin | t_xmax | t_ctid | t_infomask | xmin_frozen | t_data
    -----+--------+--------+--------+------------+-------------+--------
       1 |        |        |        |            |             |
       2 |        |        |        |            |             |
       3 |        |        |        |            |             |
       4 |        |        |        |            |             |
       5 |        |        |        |            |             |
       6 |        |        |        |            |             |
       7 |        |        |        |            |             |
       8 |        |        |        |            |             |
   ```
   - 테이블의 Age는 5이며, vacuum_freeze_table_age는 50임.
   - dead tuple은 그대로이므로 vacuum은 안되었음을 알 수 있음.
   
  5. 트랜잭션 ID 50 소모 후 Age 확인
   ```
   pgbench -h localhost -p 5432 -U postgres -d pgbench -c 1 -j 4 -t 50

   select relname, reltuples, age(relfrozenxid) from pg_class where relname='test1';
     relname | reltuples | age
    ---------+-----------+-----
     test1   |      1000 |  59   
   ```

   6. 테이블 Freeze 여부 확인
   ```
   SELECT lp, t_xmin, t_xmax, t_ctid, t_infomask::bit(16)
           ,b'0000001100000000' & t_infomask::bit(16) = b'0000001100000000' as XMIN_FROZEN
           ,t_data
   FROM heap_page_items(get_raw_page('test1', 0));
     lp  | t_xmin | t_xmax | t_ctid | t_infomask | xmin_frozen | t_data
    -----+--------+--------+--------+------------+-------------+--------
       1 |        |        |        |            |             |
       2 |        |        |        |            |             |
       3 |        |        |        |            |             |
       4 |        |        |        |            |             |
       5 |        |        |        |            |             |
       6 |        |        |        |            |             |
       7 |        |        |        |            |             |
       8 |        |        |        |            |             |
       
   ```
   - dead tuple이 그대로 조회되는 것으로 보아 Freeze 안되었음.
  
  6. vacuum_freeze_min_age 파라미터 확인
   ```
    show vacuum_freeze_min_age
    vacuum_freeze_min_age
    -----------------------
    100
   ```

  7. 트랜잭션 ID 50 소모 후 Freeze 여부 확인
   ```
   pgbench -h localhost -p 5432 -U postgres -d pgbench -c 1 -j 4 -t 50

   select relname, reltuples, age(relfrozenxid) from pg_class where relname='test1';
    relname | reltuples | age
   ---------+-----------+-----
    test1   |      1000 | 110

   SELECT lp, t_xmin, t_xmax, t_ctid, t_infomask::bit(16)
           ,b'0000001100000000' & t_infomask::bit(16) = b'0000001100000000' as XMIN_FROZEN
           ,t_data
   FROM heap_page_items(get_raw_page('test1', 0));
     lp  | t_xmin | t_xmax | t_ctid | t_infomask | xmin_frozen | t_data
    -----+--------+--------+--------+------------+-------------+--------
       1 |        |        |        |            |             |
       2 |        |        |        |            |             |
       3 |        |        |        |            |             |
       4 |        |        |        |            |             |
       5 |        |        |        |            |             |
       6 |        |        |        |            |             |
       7 |        |        |        |            |             |
   ```
   - 테이블의 Age가 110으로 vacuum_freeze_min_age = 100을 초과했음
   - 하지만 dead tuple은 정리되지 않았음...
