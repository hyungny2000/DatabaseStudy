## Freezing 작동방식
- Freezing 동작에는 Lazy Mode, Eager Mode가 있다. 공식적으로 Laze Mode, Eager Mode가 아니라 normal mode, aggressive mode라고 한다.
- 테이블의 Age가 **vacuum_freeze_table_age**를 초과하면 Eager Mode, 아니면 Lazy Mode로 동작한다.
- Lazy, Eager Mode 상관없이 튜플의 Age가 **vacuum_freeze_min_age**를 초과하면 Freezing된다.

## Lazy Mode
### 정의
- 테이블의 Age가 vacuum_freeze_table_age를 초과하지 않을 때 동작하는 모드
- 테이블의 Visibility Map에서 ALL_VISIBLE=0인 페이지의 튜플을 찾아 Freezing 실시

### 동작방식
1. 테이블의 VM파일을 스캔하여 ALL_VISIBLE=0인 페이지를 탐색한다.
2. 페이지의 dead_tuple을 제거한다.
3. 해당 페이지의 튜플 중 vacuum_freeze_min_age를 초과한 튜플을 Freezing한다.
4. VM파일에 해당 페이지의 ALL_VISIBLE=1로 수정한다.

### Lazy Mode 테스트

## Eager Mode (Aggressive Mode)
### 정의
- 테이블의 Age가 vacuum_freeze_table_age를 초과할 때 동작하는 모드
- 테이블의 Visibility Map에서 ALL_FROZEN=0인 페이지의 튜플을 찾아 Freezing 실시
- 9.6 이전에는 모든 페이지를 스캔하여 Freezing 실시했었음.

### Lazy Mode에서의 맹점
Insert만 되고 Update/Delete는 없는 로그성 테이블의 경우, dead tuple은 없으므로 ALL_VISIBLE=1, ALL_FROZEN=0이다. Lazy Mode동작은 하지 않지만, Insert된 데이터들의 XMIN도 너무 오래되면 Freezing 과정을 거쳐야 하므로 ALL_FROZEN=0인 페이지를 Freezing하기 위해 Eager Mode가 필요하다.

### 동작방식
1. 테이블의 VM파일을 스캔하여 ALL_FROZEN=0인 페이지를 탐색한다.
2. 페이지의 dead tuple을 제거한다.
3. 해당 페이지의 튜플 중 vacuum_freeze_min_age를 초과한 튜플을 Freezing한다.
4. VM파일에 해당 페이지의 ALL_VISIBLE=1, ALL_FROZEN=1로 수정한다.
5. 테이블의 Age를 vacuum_freeze_min_age와 일치하도록 pg_class.relfrozenxid 값을 갱신함.
   ```
   pg_class.relfrozenxid = OldestXIDInProgress - vacuum_freeze_min_age
   - pg_class.relfrozenxid : 테이블의 FrozenXID
   - OldestXIDInProgress : 현재 진행중인 트랜잭션ID 중 가장 오래된 ID
   ```
   - 모든 튜플의 Age가 vacuum_freeze_min_age를 초과하지 않음을 보장하므로 테이블의 Age 또한 이에 맞추는 것이다.

### Eager Mode 테스트
