## Checkpoint

#### 정의
Commit 또는 Rollback을 수행하면 트랜잭션은 종료되고, XLOG Record는 WAL Buffer에 적재되고, WAL Segment 파일로 Flush되어 페이지 변경사항이 디스크로 안전하게 백업된다. 변경된 버퍼에도 Commit/Rollback LSN이 기록되어 추후 복구할 때 사용된다. 이렇게만 해도 WAL Log를 통해 데이터를 복구할 수 있으므로, 데이터는 영구히 지속될 수 있다고 할 수 있다.      
하지만 최신 버전의 버퍼는 아직 Shared Buffer에만 머무는 상태이며, 디스크로 Flush되지 않은 상태이다. 이 시점 버퍼와 대응되는 페이지 간의 데이터 차이가 발생하는데, 이를 Dirty Buffer라고 한다. **Checkpoint동작은 주기적으로 Shared Buffer내의 Dirty Buffer를 디스크로 Flush하여 버퍼와 데이터파일의 페이지 간 동기화를 이루는 것을 말한다. 최신 버전의 버퍼를 데이터파일에 반영하여 데이터파일을 최신버전으로 업데이트하는 행위인 것이다.**

#### Checkpoint가 없다면...
Checkpoint가 없어도 WAL Segment파일만 온전히 있다면 얼마든지 복구할 수 있기 때문에 데이터는 영구히 지속된다고 말할 수 있다. 다만 다음과 같은 문제가 발생한다.

| 일시 | 상황 |
| --- | --- |
| 1월 1일 09:00 | initdb로 초기화, DB오픈 | 
| 1월 2일 09:00 | WAL파일 1GB 적재 | 
| 1월 3일 09:00 | WAL파일 1GB 적재 | 
| 1월 4일 09:00 | WAL파일 1GB 적재 | 
| 1월 5일 09:00 | WAL파일 1GB 적재 | 
| 1월 6일 09:00 | WAL파일 1GB 적재 | 
| 1월 7일 09:00 | WAL파일 1GB 적재. 이후 DB Shutdown |
| 1월 8일 09:00 | WAL파일 1GB 적재 | 
| 1월 9일 09:00 | WAL파일 1GB 적재 | 
| 1월 10일 09:00 | WAL파일 1GB 적재 | 
| 1월 11일 09:00 | WAL파일 1GB 적재 | 
| 1월 12일 09:00 | WAL파일 1GB 적재 | 
| 1월 13일 09:00 | WAL파일 1GB 적재 | 
| 1월 14일 09:00 | WAL파일 1GB 적재. 이후 DB Shutdown | 

1월 1일 DB오픈한 이래로 Checkpoint를 한 번도 하지 않았다면, 디스크의 데이터파일 버전은 1월 1일에 그대로 머물 것이다. 이후 1월 7일까지 모든 변경사항을 WAL Segment파일로 기록했다가 DB가 내려갔다고 가정한다. 이 때까지 Checkpoint가 한 번도 일어나지 않았다면 DB기동할 때 다음과 같은 일이 발생한다.    
1. DB기동할 때 데이터파일을 로딩한다. 이 때 데이터파일 버전은 1월 1일 9시이기 때문에 이대로는 오픈할 수 없다.
2. 1월 1일 9시 DB오픈시점부터 DB Shutdown 직전까지 누적된 WAL Segment파일의 트랜잭션 로그를 모조리 순차적으로 데이터파일에 적용한다. 이 과정을 Crash Recovery라고 부르며, WAL Segment파일의 트랜잭션 로그를 순차적으로 하나하나 적용하는 행위를 롤 포워딩(Roll Forwarding)이라고 한다. **WAL Segment파일 총 6GB가 모두 데이터파일에 복구될 때까지 DB는 절대 오픈되지 않고, 서비스 다운타임은 그만큼 길어진다.**

Checkpoint가 없어서 발생하는 문제점은 다음과 같다.
1. 일주일 뒤인 1월 14일에도 마찬가지로 데이터파일은 1월 1일 9시 버전이므로, DB오픈시에는 1월 1일 9시부터 1월 14일 DB Shutdown시점까지 **총 13GB에 달하는 어마어마한 용량의 WAL Segment파일의 변경사항을 빠짐없이 적용해야 DB를 오픈할 수 있다.**         
2. 시간이 가면 갈수록 보관해야 하는 WAL Segment파일의 용량은 지속적으로 증가하므로 스토리지 용량부담이 커지며, DB오픈 시 복구해야 하는 양이 늘어나면서 서비스 다운타임이 지속적으로 증가하게 된다.
3. 지속적으로 생성되는 WAL Segment파일은 절대로 삭제할 수 없다. 만일 1월 1일 9시 이후의 WAL Segment파일 중 단 하나라도 삭제되거나 손상되면 최신 시점으로의 DB오픈은 불가능하므로 삭제된 Segment파일의 직전 까지밖에 복구할 수 없게 된다.
  
#### 실제 Checkpoint
| 일시 | 상황 |
| --- | --- |
| 1월 1일 09:00 | initdb로 초기화, DB오픈 | 
| 1월 1일 09:01 | WAL파일 1MB 적재, Checkpoint | 
| 1월 1일 09:02 | WAL파일 1MB 적재, Checkpoint | 
| 1월 1일 09:03 | WAL파일 1MB 적재, Checkpoint | 
| 1월 1일 09:04 | WAL파일 1MB 적재, Checkpoint | 
| 1월 1일 09:05 | WAL파일 1MB 적재, DB Shutdown in mornal mode | 

1월 1일 9시 DB오픈 이래로 1분마다 Checkpoint가 발생한다고 가정한다. 또한 **DB가 정상적으로 Shutdown될 때는 항상 Checkpoint가 끝난 다음에 종료하게끔** 되어 있기 때문에 **DB기동 시 Crash Recovery가 불필요**하게 된다.      
DB서버에 장애가 발생해서 DB가 비정상적으로 종료하게 되면 Checkpoint를 하지 못하게 된다. 하지만 예시에선 Checkpoint주기가 1분 정도로 비교적 주기가 짧기 때문에 Crash Recovery에 필요한 WAL Segment의 양은 1MB정도로 훨씬 적고 당연히 복구시간도 훨씬 적게 든다. Checkpoint 시점에 데이터파일의 페이지 버전이 이미 최신버전으로 갱신되었으므로, Checkpoint 이전의 WAL 파일은 불필요하게 된다. 물론 백업, 복구 또는 이중화를 위해 일정 개수 이상은 보관해야 하지만, 최소한 Crash Recovery만 생각하면 불필요해지게 된다.

#### Checkpoint 실행시점
1. smart, fast mode로 DB Shutdown시
2. pg_basebackup 또는 pg_start_backup() 실행 시점
3. 아무 이벤트도 없을 때 checkpoint_timeout 파라미터에 명시된 기간(초) 주기로 반복실시 (기본값 300초)
4. 자동 체크포인트 이후 WAL Segment파일의 크기가 max_wal_file 설정값을 초과했을 때.
5. checkpoint 명령 수동 실행
