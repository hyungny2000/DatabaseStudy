## Transaction Snapshot

#### MVCC
- Multi Version Consistency Control의 약자
- 현재 쿼리, 트랜잭션 실행시점보다 과거의 데이터는 볼 수 있다.
- 현재 진행형 또는 미래의 트랜잭션 변경사항은 볼 수 없다.
- 동일한 데이터여도 트랜잭션 시작시점에 따라 볼 수 있는 데이터 버전은 각각 다르다.

#### Transaction Snapshot
```
SELECT * FROM txid_current_snapshot(); -- v12까지
SELECT * FROM pg_current_snapshot(); --13v부터

txid_current_snapshot
____ ____ ____________
 xmin:xmax:xip
```
- 현재 시점에 진행중인 트랜잭션의 시작XID(XMIN)정보를 스냅샷 형태로 받는다.
- XMIN : 가장 오래된 현재진행형 트랜잭션의 시작XID
- XMAX : 가장 늦게 시작된 현재진행형 트랜잭션의 시작XID
- XIP : XMIN ~ XMAX 사이의 현재 진행중인 트랜잭션들의 XID목록. (콤마로 구분)

#### Transaction Snapshot 해석
- XMIN 트랜잭션ID보다 작은 트랜잭션ID는 모두 Visible한 데이터로 간주함.
- XMAX 트랜잭션ID와 같거나 큰 트랜잭션ID는 모두 Invisible한 데이터로 간주함.
- XIP는 현재진행형(In Progress)한 트랜잭션ID이므로 Invisible한 데이터로 간주함.
- 예를 들어 Transaction Snapshot이 다음과 같다고 하자.
  ```
  100:105:101,102,104
  ```
   - 현재 진행중인 트랜잭션의 ID는 100번, 101번, 102번, 104번, 105번이고, 이 트랜잭션의 데이터는 Invisible하다.
   - XMIN=100번이므로 100보다 작은 트랜잭션은 Visible함.
   - XMAX=105번이므로 105와 같거나 큰 트랜잭션은 Invisible함.

#### Transaction Snapshot 테스트
1. Session 4개를 열어 각각 아래 명령을 실행한다.

| session#1 | session#2 | session#3 | session#4 |
| --- | --- | --- | --- |
|\set autocommit off; <br>SELECT txid_current();<br>begin;<br>insert into test1 values (1); | \set autocommit off; <br>SELECT txid_current();<br>begin;<br>insert into test1 values (2); | \set autocommit off; <br>SELECT txid_current();<br>begin;<br>insert into test1 values (3); | \set autocommit off; <br>SELECT txid_current();<br>begin;<br>insert into test1 values (4); |

2. 다른 CMD창을 띄워 트랜잭션 XID 확인
```
select pid, backend_xid, query
from pg_stat_activity
where backend_type='client backend';
```
- pid : 프로세스ID
- backend_xid : 백엔드 프로세스의 트랜잭션ID
- query : 작업쿼리
```
nano=# select pid, backend_xid, query
from pg_stat_activity
where backend_type='client backend';
 pid | backend_xid |                query
-----+-------------+--------------------------------------
 134 |         584 | insert into test1 values (1);
 204 |         586 | insert into test1 values (2);
 275 |         588 | insert into test1 values (3);
 345 |         590 | insert into test1 values (4);
```

| 세션명 | pid | backend_xid | query |
| --- | --- | --- | --- |
| Session#1 | 134| 584| insert into test1 values (1); |
| Session#2 | 204| 586| insert into test1 values (2); |
| Session#3 | 275| 588| insert into test1 values (3); |
| Session#4 | 424| 590| insert into test1 values (4); |

1. 트랜잭션 레벨 별로 각각 CMD 또는 DBeaver 창을 열어 스냅샷, 테이블데이터 조회하도록 세팅

| Read Uncommitted | Read Committed | Repeatable Read | Serializable |
| --- | --- | --- | --- |
| begin;<br>SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;<br>select txid_current_snapshot();<br>select * from test1; | begin;<br>SET TRANSACTION ISOLATION LEVEL READ COMMITTED;<br>select txid_current_snapshot();<br>select * from test1; | begin;<br>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;<br>select txid_current_snapshot();<br>select * from test1; | begin;<br>SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;<br>select txid_current_snapshot();<br>select * from test1; |

4. Session 4개를 2,3,4,1번 순서대로 커밋하면서 각 트랜잭션 레벨 별로 스냅샷, 데이터 조회하기
 - Read Uncommitted

   | 작업 | 트랜잭션 스냅샷 | 데이터 |
   | --- | --- | --- |
   | 초기 |584:590:584,586,588 | X |
   | Session#2 (586) 커밋 | 584:590:584,588  | 2|
   | Session#3 (588) 커밋 |  584:590:584 | 2,3|
   | Session#4 (590) 커밋 | 584:591:584 | 2,3,4 |
   | Session#1 (584) 커밋 | 591:591: |1,2,3,4 |
   - PostgreSQL에서는 공식적으로 Read Uncommitted 격리레벨을 지원하지 않는다. 모든 트랜잭션이 진행중인(Uncommitted) 상황에서도 어떤 데이터도 조회되지 않고, Read Committed격리레벨처럼 동작한다. 자세한 설명은 Read Committed에서 진행.

> #### Read Uncommitted 격리레벨 미지원 ([매뉴얼 링크](https://www.postgresql.org/docs/current/transaction-iso.html))
> In PostgreSQL, you can request any of the four standard transaction isolation levels, but internally only three distinct isolation levels are implemented, i.e., PostgreSQL's Read Uncommitted mode behaves like Read Committed. This is because it is the only sensible way to map the standard isolation levels to PostgreSQL's multiversion concurrency control architecture.

- Read Committed

   | 작업 | 트랜잭션 스냅샷 | 데이터 | 설명 |
   | --- | --- | --- | --- |
   | 초기 |584:590:584,586,588 | X | TxID 584, 586, 588, 590 모두 활성상태이므로 데이터 조회불가|
   | Session#2 (586) 커밋 | 584:590:584,588 | 2 | 586번 트랜잭션이 비활성상태이므로 2번 조회됨 |
   | Session#3 (588) 커밋 | 584:590:584 | 2,3 | 586, 588번 트랜잭션 비활성이므로 2,3번 조회됨 |
   | Session#4 (590) 커밋 | 584:591:584 | 2,3,4| 586, 588, 590번 트랜잭션 비활성이므로 2,3,4번 조회됨 |
   | Session#1 (584) 커밋 |591:591: | 1,2,3,4| 584, 586, 588, 590 모두 비활성이므로 1,2,3,4모두 조회됨 |
  - Read Committed 격리레벨에서는 트랜잭션 내에서 쿼리 1회 실행할 때마다 트랜잭션 스냅삿을 조회한다.
  - 따라서, 트랜잭션 중간에 데이터가 변경되서 커밋되면, 커밋된 대로 조회된다.
- Repeatable Read

   | 작업 | 트랜잭션 스냅샷 | 데이터 |
   | --- | --- | --- |
   | 초기 |584:590:584,586,588 | X |
   | Session#2 (586) 커밋 | 584:590:584,586,588 | X |
   | Session#3 (588) 커밋 |  584:590:584,586,588 |X |
   | Session#4 (590) 커밋 |584:590:584,586,588 |X |
   | Session#1 (584) 커밋 | 584:590:584,586,588|X |
  - Repeatable Read 격리레벨에서는 트랜잭션 시작 시 받은 트랜잭션 스냅샷을 트랜잭션 종료시점까지 유지하므로, 다른 트랜잭션에 의해 데이터가 변경되거나 말거나 트랜잭션 내내 데이터의 일관성을 유지한다.
- Serializable

   | 작업 | 트랜잭션 스냅샷 | 데이터 |
   | --- | --- | --- |
   | 초기 |584:590:584,586,588 | X |
   | Session#2 (586) 커밋 | 584:590:584,586,588 | X |
   | Session#3 (588) 커밋 | 584:590:584,586,588 | X |
   | Session#4 (590) 커밋 | 584:590:584,586,588 | X |
   | Session#1 (584) 커밋 | 584:590:584,586,588| X |
  - Serializable 격리레벨에서는 Repeatable Read와 마찬가지로 트랜잭션 시작 시 트랜잭션 스냅샷을 트랜잭션 종료시점까지 유지한다. 이 테스트에선 나타나지 않지만, Serializable레벨은 Repeatable Read 단계에서 직렬화를 한 단계 더 거치는데 본 테스트에서는 나타나지 않는다.

#### 결론
- 트랜잭션 스냅샷은 현재진행형 트랜잭션의 시작XID목록을 표시한다.
- 트랜잭션 스냅샷 형식
  - XMIN : 가장 오래된 트랜잭션 XID. 이보다 과거의 트랜잭션은 일단 Visible하다.
  - XMAX : 가장 나중에 실행된 트랜잭션 XID, 이 XID를 포함한 미래의 트랜잭션은 모두 Invisible하다.
  - XIP : 현재진행형 트랜잭션 XID목록. 현재진행형 트랜잭션의 XID이므로 이 트랜잭션의 변경내용은 표시되지 않는다.
- 트랜잭션 스냅샷 조회시점은 트랜잭션 격리레벨에 따라 다르다.
  - Read Uncommitted는 지원하지 않으므로 고려하지 않는다.
  - Read Committed 격리레벨의 트랜잭션은 쿼리를 실행하는 시점에 트랜잭션 스냅샷을 얻으므로, 쿼리 실행시마다 데이터 변경이 발생할 수 있다.
  - Repeatable Read, Serializable 격리레벨의 경우에는 트랜잭션 시작시점에만 트랜잭션 스냅샷을 얻으므로, 트랜잭션 진행중 데이터 일관성이 유지된다.
