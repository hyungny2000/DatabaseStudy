## Transaction Snapshot

#### MVCC
- Multi Version Consistency Control의 약자
- 동일한 데이터라도 각 트랜잭션의 격리레벨, 활성화여부, 시작시점에 따라 봐야 하는 데이터 버전이 다르다.
- 일반적으로 쿼리가 실행된 시점보다 과거시점의 데이터는 볼 수 있고, 현재 진행중이거나 미래 버전의 데이터는 볼 수 없다.
- 데이터 버전이 하나라면 Select쿼리를 실행해도 해당 데이터에 Lock을 걸어야 변경을 막을 수 있으므로 동시성이 매우 떨어짐.
- 여러 버전의 데이터를 남겨놓음으로써, Lock 없이도 과거 버전의 데이터를 볼 수 있게 함.

#### 타 RDBMS (Oracle)의 MVCC
- Update/Delete 시작 시 Undo블록을 확보한다.
- Update/Delete 직전 원본 블록을 Undo블록으로 백업한 후에 원본 블록을 변경한다. 해당 Undo블록이 현 블록의 과거버전인 셈이다.
- Select 쿼리 실행시점 버전에 해당하는 Undo블록을 로딩하여 데이터를 조회함.

#### PostgreSQL의 MVCC
- Update시 구버전 힙 튜플은 infomask만 수정한 채 Dead Tuple이 되고, 신규버전 힙 튜플을 새로 생성한다.
- Delete시 구버전 힙 튜플은 infomask만 수정한 채 Dead Tuple이 된다.
- 과거 버전의 힙 튜플이 있어서 이를 조회함으로써 MVCC를 구현한다.

#### Transaction Snapshot
```
SELECT * FROM txid_current_snapshot(); -- v12까지
SELECT * FROM pg_current_snapshot(); --13v부터

txid_current_snapshot
____ ____ ____________
 xmin:xmax:xip
```
- 현재 시점에 진행중인 트랜잭션의 시작XID(XMIN)정보를 스냅샷 형태로 받는다.
- XMIN : 가장 오래된 현재진행형 트랜잭션의 시작XID
- XMAX : 가장 늦게 시작된 현재진행형 트랜잭션의 시작XID
- XIP : XMIN ~ XMAX 사이의 현재 진행중인 트랜잭션들의 XID목록. (콤마로 구분)

#### Commit Log와 Transaction Snapshot 차이점
트랜잭션 정보를 관리한다는 면에서 Commit Log와 Transaction Snapshot이 마치 동일한 것처럼 느껴지지만 다음 차이점이 있다.
1. Commit Log : 각 트랜잭션의 상태 (COMMIT, ABORT, IN_PROGRESS, SUB_COMMIT)를 보유하며, 특히 Transaction Snapshot에는 없는 COMMIT/ABORT여부까지 알고 있다.
2. Transaction Snapshot : 오직 현재 진행중인 트랜잭션XID정보만을 보여준다. Commit/Abort여부는 알지 못한다.

#### Transaction Snapshot 해석
- XMIN 트랜잭션ID보다 작은 유효한(Committed) 트랜잭션ID는 모두 Visible한 데이터로 간주함.
- XMAX 트랜잭션ID와 같거나 큰 트랜잭션ID는 모두 Invisible한 데이터로 간주함.
- XIP는 현재진행형(In Progress)한 트랜잭션ID이므로 Invisible한 데이터로 간주함.
- 예를 들어 Transaction Snapshot이 다음과 같다고 하자.
  ```
  100:104:100,102,103
  ```
   - 현재 진행중인 트랜잭션의 ID는 100번,102번,103번,104번이고, 이 트랜잭션의 데이터는 Invisible하다. 이 시점 102번 트랜잭션이 Commit으로 종료했다고 하더라도, 일단 Transaction Snapshot의 목록에 있다면 활성 트랜잭션으로 간주된다.
   - XMIN=100번이므로 100보다 과거의 트랜잭션은 일단 Visible함.
   - XMAX=104번이므로 104이거나(현재진행형임) 더 미래 버전의 트랜잭션은 Invisible함.

#### Transaction Snapshot 테스트
1. Session 4개를 열어 각각 아래 명령을 실행한다.
2. 데이터를 insert하고 커밋은 하지 않는다.

| session#1 | session#2 | session#3 | session#4 |
| --- | --- | --- | --- |
|\set autocommit off; <br>begin;<br>SELECT txid_current();<br>insert into test1 values (1); | \set autocommit off; <br>begin;<br>SELECT txid_current();<br>insert into test1 values (2); | \set autocommit off; <br>begin;<br>SELECT txid_current();<br>insert into test1 values (3); | \set autocommit off; <br>begin;<br>SELECT txid_current();<br>insert into test1 values (4); |

2. 다른 CMD창을 띄워 트랜잭션 XID 확인
```
select pid, backend_xid, query
from pg_stat_activity
where backend_type='client backend';
```
- pid : 프로세스ID
- backend_xid : 백엔드 프로세스의 트랜잭션ID
- query : 작업쿼리
```
nano=# select pid, backend_xid, query
from pg_stat_activity
where backend_type='client backend';
 pid | backend_xid |                query
-----+-------------+--------------------------------------
 134 |         584 | insert into test1 values (1);
 204 |         586 | insert into test1 values (2);
 275 |         588 | insert into test1 values (3);
 345 |         590 | insert into test1 values (4);
```

| 세션명 | pid | backend_xid | query |
| --- | --- | --- | --- |
| Session#1 | 134| 584| insert into test1 values (1); |
| Session#2 | 204| 586| insert into test1 values (2); |
| Session#3 | 275| 588| insert into test1 values (3); |
| Session#4 | 424| 590| insert into test1 values (4); |

1. 트랜잭션 레벨 별로 각각 CMD 또는 DBeaver 창을 열어 스냅샷, 테이블데이터 조회하도록 세팅

| Read Uncommitted | Read Committed | Repeata한 트랜잭션은 일단 Visible하다.
  - XMAX : 가장 나중에 실행된 트랜잭션 XID, 이 XID를 포함한 미래의 트랜잭션은 모두 Invisible하다.
  - XIP : 현재진행형 트랜잭션 XID목록. 현재진행형 트랜잭션의 XID이므로 이 트랜잭션의 변경내용은 표시되지 않는다.
- 트랜잭션 스냅샷 조회시점은 트랜잭션 격리레벨에 따라 다르다.
  - Read Uncommitted는 지원하지 않으므로 고려하지 않는다.
  - Read Committed 격리레벨의 트랜잭션은 쿼리를 실행하는 시점에 트랜잭션 스냅샷을 얻으므로, 쿼리 실행시마다 데이터 변경이 발생할 수 있다.
  - Repeatable Read, Serializable 격리레벨의 경우에는 트랜잭션 시작시점에만 트랜잭션 스냅샷을 얻으므로, 트랜잭션 진행중 데이터 일관성이 유지된다.
